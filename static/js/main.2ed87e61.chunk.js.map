{"version":3,"sources":["Components/Header/Header.tsx","api/api.ts","Components/ModalWindow/ModalWindow.tsx","Components/Gallery/GalleryItem.tsx","Components/Gallery/Gallery.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["Header","handleSearchClick","handleGroupClick","handleClearClick","handleImageClick","isLoading","searchTag","group","useState","tag","setTag","useEffect","className","Container","Input","type","name","placeholder","value","onBlur","evt","onChange","target","Button","color","disabled","onClick","instance","axios","create","baseURL","giphyAPI","get","params","api_key","ModalWindow","message","isOpen","setModal","Modal","ModalHeader","ModalFooter","open","GalleryItem","imageUrl","styles","iFrameWrapper","width","height","paddingBottom","position","iFrame","right","iFrameButton","top","left","bottom","zIndex","Col","sm","style","src","frameBorder","allowFullScreen","Gallery","data","tagList","setTagList","tags","forEach","item","Object","values","map","itemTag","key","Row","filter","index","App","setSearchTag","state","setState","setGroup","setIsLoading","modal","fetchRandomImages","a","response","Array","isArray","length","Error","newStateItem","embed_url","prevState","console","log","error","status","preventDefault","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch"],"mappings":"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","file":"static/js/main.2ed87e61.chunk.js","sourcesContent":["import React, {useEffect, useState} from \"react\";\nimport {Input, Container, Button} from 'reactstrap';\n\ninterface IHeader {\n    handleSearchClick: (evt: React.MouseEvent<HTMLElement>, tag: string | undefined) => void;\n    handleGroupClick: (evt: React.MouseEvent<HTMLElement>) => void;\n    handleClearClick: (evt: React.MouseEvent<HTMLElement>) => void;\n    handleImageClick: (evt: React.MouseEvent<HTMLElement> | React.FocusEvent<HTMLElement>, tag: string) => void,\n    isLoading: boolean;\n    searchTag: string;\n    group: boolean;\n}\n\nexport const Header = ({\n                           handleSearchClick,\n                           handleGroupClick,\n                           handleClearClick,\n                           handleImageClick,\n                           isLoading,\n                           searchTag,\n                           group,\n                       }: IHeader) => {\n\n    const [tag, setTag] = useState(searchTag);\n\n    useEffect(() => {\n        setTag(searchTag);\n    }, [searchTag]);\n\n    return <header className=\"mt-3 mb-3\">\n        <Container className=\"d-flex flex-sm-nowrap\">\n            <Input className=\"mr-2\" type=\"text\" name=\"text\" placeholder=\"введите тег\"\n                   value={tag}\n                   onBlur={evt => handleImageClick(evt, tag)}\n                   onChange={evt => setTag(evt.target.value)}/>\n            <Button className=\"mr-2\" color=\"success\"\n                    disabled={isLoading}\n                    onClick={evt => handleSearchClick(evt, tag)}>\n                {isLoading ? 'Загрузка...' : 'Загрузить'}\n            </Button>\n            <Button className=\"mr-2\" color=\"danger\"\n                    onClick={handleClearClick}>Очистить</Button>\n            <Button color=\"primary\"\n                    onClick={handleGroupClick}>\n                {group ? 'Разгруппировать' : 'Группировать'}\n            </Button>\n        </Container>\n    </header>\n};","import axios, {AxiosResponse} from 'axios';\n\nconst instance = axios.create({\n    baseURL: 'https://api.giphy.com/v1/gifs',\n});\n\nexport const giphyAPI = {\n    getRandomImg(tag: string): Promise<AxiosResponse<any>> {\n        return instance.get(`/random`, {\n            params: {\n                tag: tag,\n                api_key: \"eRLxLG7aD0evVVEdqxCHgsSSVbeDm7LI\"\n            }\n        })\n    }\n};","import React from 'react';\nimport {Button, Modal, ModalHeader, ModalFooter} from 'reactstrap';\n\ninterface IModalWindow {\n    message: string,\n    isOpen: boolean,\n    setModal: any,\n}\n\nconst ModalWindow = ({\n                         message,\n                         isOpen,\n                         setModal,\n                     }: IModalWindow) => {\n\n    const toggle = () => setModal({\n        open: !isOpen,\n        message: ''\n    });\n\n    return (\n        <div>\n            <Modal isOpen={isOpen}>\n                <ModalHeader>{message}</ModalHeader>\n                <ModalFooter>\n                    <Button color=\"primary\" onClick={toggle}>Закрыть</Button>\n                </ModalFooter>\n            </Modal>\n        </div>\n    );\n};\n\nexport default ModalWindow;","import React from \"react\";\nimport {Col} from \"reactstrap\";\n\ninterface IGalleryItem {\n    imageUrl: string;\n    tag: string\n    handleImageClick: (evt: React.MouseEvent<HTMLElement>, tag: string) => void,\n}\n\nexport const GalleryItem = ({\n                                imageUrl,\n                                tag,\n                                handleImageClick,\n                            }: IGalleryItem) => {\n    const styles = {\n        iFrameWrapper: {\n            width: \"100%\",\n            height: \"0\",\n            paddingBottom: \"75%\",\n            position: 'relative' as 'relative'\n        },\n        iFrame: {\n            position: 'absolute' as 'absolute',\n            right: \"0\"\n        },\n        iFrameButton: {\n            position: 'absolute' as 'absolute',\n            top: 0,\n            left: 0,\n            right: 0,\n            bottom: 0,\n            zIndex: 5000\n        }\n    };\n\n    return (\n        <Col sm={4} className=\"border rounded\">\n            <div style={styles.iFrameWrapper}>\n                <iframe src={imageUrl} width=\"100%\" height=\"100%\"\n                        style={styles.iFrame} frameBorder=\"0\" className=\"giphy-embed\"\n                        allowFullScreen> </iframe>\n                <div style={styles.iFrameButton}\n                     onClick={evt => handleImageClick(evt, tag)}> </div>\n            </div>\n        </Col>\n    )\n};","import React, {useEffect, useState} from \"react\";\nimport {Container, Row} from \"reactstrap\";\nimport {IStateItem} from \"../../App\";\nimport {GalleryItem} from \"./GalleryItem\";\n\ninterface IGallery {\n    handleImageClick: (evt: React.MouseEvent<HTMLElement>, tag: string) => void,\n    data: IStateItem[],\n    group: boolean\n}\n\nexport const Gallery = ({\n                            handleImageClick,\n                            data,\n                            group,\n                        }: IGallery) => {\n\n    const defaultTagList: string[] = [];\n    const [tagList, setTagList] = useState(defaultTagList);\n\n    useEffect(() => {\n        const tags: { [key: string]: string; } = {};\n        data.forEach(item => tags[item.tag] = item.tag);\n        setTagList(Object.values(tags));\n    }, [data]);\n\n    if (!group) return <section>\n        <Container>\n            <Row>\n                {data.map((item, index) =>\n                    <GalleryItem key={index}\n                                 imageUrl={item.imageUrl}\n                                 tag={item.tag}\n                                 handleImageClick={handleImageClick}/>\n                )}\n            </Row>\n        </Container>\n    </section>;\n\n    return <section>\n        <Container>\n            {tagList.map(itemTag =>\n                <div key={itemTag} className=\"p-3 border rounded\">\n                    <h3 className=\"mb-2 text-left\">{itemTag}</h3>\n                    <Row>\n                        {data.filter(item => item.tag === itemTag).map((item, index) =>\n                            <GalleryItem key={index}\n                                         imageUrl={item.imageUrl}\n                                         tag={item.tag}\n                                         handleImageClick={handleImageClick}/>\n                        )}\n                    </Row>\n                </div>\n            )}\n        </Container>\n    </section>\n};","import React, {useState} from 'react';\nimport {Header} from \"./Components/Header/Header\";\nimport {giphyAPI} from \"./api/api\";\nimport ModalWindow from \"./Components/ModalWindow/ModalWindow\";\nimport {Gallery} from \"./Components/Gallery/Gallery\";\n\ninterface IResponse {\n    data: {\n        data: { embed_url: string }\n    }\n}\n\nexport interface IStateItem {\n    imageUrl: string,\n    tag: string\n}\n\nfunction App() {\n    const defaultState: IStateItem[] = [];\n    const [searchTag, setSearchTag] = useState('');\n    const [state, setState] = useState(defaultState);\n    const [group, setGroup] = useState(false);\n    const [isLoading, setIsLoading] = useState(false);\n    const [modal, setModal] = useState({\n        open: false,\n        message: ''\n    });\n\n    const getErrorMessage = (error: any): string => {\n        if (error.response) {\n            if (error.response.status === 429) return 'Слишком много запросов на сервер';\n            return 'Произошла http ошибка';\n        }\n        return error.message;\n    };\n\n    const fetchRandomImages = async (tag: string) => {\n        setIsLoading(true);\n        try {\n            const response: IResponse = await giphyAPI.getRandomImg(tag);\n\n            if (Array.isArray(response.data.data) && !response.data.data.length)\n                throw new Error('По тегу ничего не найдено');\n\n            let newStateItem: IStateItem = {\n                imageUrl: response.data.data.embed_url,\n                tag: tag\n            };\n            setState((prevState => [...prevState, newStateItem]));\n            setIsLoading(false);\n        } catch (error) {\n            setIsLoading(false);\n            console.log('Error - ', error.message);\n\n            setModal({\n                open: true,\n                message: getErrorMessage(error)\n            });\n        }\n    };\n\n    const handleSearchClick = (evt: React.MouseEvent<HTMLElement>, tag: string | undefined): void => {\n        evt.preventDefault();\n        tag && fetchRandomImages(tag);\n        !tag && setModal({\n            open: true,\n            message: 'заполните поле \"тег\"'\n        });\n    };\n\n    const handleGroupClick = (evt: React.MouseEvent<HTMLElement>): void => {\n        evt.preventDefault();\n        setGroup(prevState => !prevState);\n    };\n\n    const handleClearClick = (evt: React.MouseEvent<HTMLElement>): void => {\n        evt.preventDefault();\n        setState([]);\n    };\n\n    const handleImageClick = (evt: React.MouseEvent<HTMLElement> | React.FocusEvent<HTMLElement>, tag: string): void => {\n        evt.preventDefault();\n        setSearchTag(tag);\n    };\n\n    return (\n        <div className=\"App\">\n            <Header handleSearchClick={handleSearchClick}\n                    handleGroupClick={handleGroupClick}\n                    handleClearClick={handleClearClick}\n                    handleImageClick={handleImageClick}\n                    isLoading={isLoading}\n                    searchTag={searchTag}\n                    group={group}/>\n            {state.length\n                ? <Gallery data={state}\n                           handleImageClick={handleImageClick}\n                           group={group}/>\n                : ''}\n            <ModalWindow isOpen={modal.open}\n                         setModal={setModal}\n                         message={modal.message}/>\n        </div>\n    );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\nserviceWorker.unregister();\n"],"sourceRoot":""}